<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · FEMTISE</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FEMTISE logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FEMTISE</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Abstract"><span>Abstract</span></a></li><li class="toplevel"><a class="tocitem" href="#Statement-of-need"><span>Statement of need</span></a></li><li class="toplevel"><a class="tocitem" href="#Capability-of-the-package"><span>Capability of the package</span></a></li><li class="toplevel"><a class="tocitem" href="#Weak-formulation-and-eigenvalue-problem-(Galerkin-Method)"><span>Weak formulation and eigenvalue problem (Galerkin Method)</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li><li class="toplevel"><a class="tocitem" href="#Implementation-of-FEMTISE-package"><span>Implementation of FEMTISE package</span></a></li></ul></li><li><a class="tocitem" href="../computing_details/">Computing details</a></li><li><a class="tocitem" href="../guide_information/">Guide Information</a></li><li><a class="tocitem" href="../function_information/">Function Information</a></li><li><span class="tocitem">Simulation Example</span><ul><li><a class="tocitem" href="../examples/simulation_example/">General Simulation Examples</a></li><li><a class="tocitem" href="../examples/symmetric_finite_1d_kronig_penney_potential/">Symmetric Finite 1D Kronig-Penney Potential</a></li><li><a class="tocitem" href="../examples/isotropic_1d_harmonic_oscillator_potential/">Isotropic 1D Quantum Harmonic Oscillator Potential</a></li><li><a class="tocitem" href="../examples/isotropic_2d_harmonic_oscillator_potential/">Isotropic 2D Quantum Harmonic Oscillator Potential</a></li><li><a class="tocitem" href="../examples/coulomb_interaction_2d_potential/">Two-Electrons Coulomb Interaction Potential</a></li></ul></li><li><a class="tocitem" href="../contact_information/">Contact Information</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mendzmartin/FEMTISE.jl/blob/main/docs/src/math_fundation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FEMTISE.jl:-A-High-Performance-Julia-Package-for-Time-Independent-Schrödinger-Equation-by-Finite-Element-Method"><a class="docs-heading-anchor" href="#FEMTISE.jl:-A-High-Performance-Julia-Package-for-Time-Independent-Schrödinger-Equation-by-Finite-Element-Method"><code>FEMTISE.jl</code>: A High Performance Julia Package for Time-Independent Schrödinger Equation by Finite Element Method</a><a id="FEMTISE.jl:-A-High-Performance-Julia-Package-for-Time-Independent-Schrödinger-Equation-by-Finite-Element-Method-1"></a><a class="docs-heading-anchor-permalink" href="#FEMTISE.jl:-A-High-Performance-Julia-Package-for-Time-Independent-Schrödinger-Equation-by-Finite-Element-Method" title="Permalink"></a></h1><blockquote><p>Méndez, Martín¹² &amp; Pont, Federico M.¹²</p></blockquote><p>¹Instituto de Física Enrique Gaviola (IFEG-FAMAF-CONICET)</p><p>²Facultad de Matemática, Astronomía, Física y Computación (FAMAF), Universidad Nacional de Córdoba (UNC), 5000, Córdoba, Argentina</p><h1 id="Abstract"><a class="docs-heading-anchor" href="#Abstract">Abstract</a><a id="Abstract-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract" title="Permalink"></a></h1><p><code>FEMTISE.jl</code> is a package to resolve Time-Independent Schrödinger Equation (TISE) by Finit Element Method (FEM). This is an implementation and extension over <a href="https://github.com/gridap/Gridap.jl">GRIDAP.jl</a> package using high performance protocol. The package is under constructions and currently can solve one and two dimensional problems for arbitrary potentials.</p><h1 id="Statement-of-need"><a class="docs-heading-anchor" href="#Statement-of-need">Statement of need</a><a id="Statement-of-need-1"></a><a class="docs-heading-anchor-permalink" href="#Statement-of-need" title="Permalink"></a></h1><p><code>FEMTISE</code> allows solving the TISE in one-dimensional and two-dimensional systems. However, it is possible to extend the package to solve systems of arbitrary dimensions (by adapting existing functions in the <a href="https://github.com/gridap/Gridap.jl">GRIDAP.jl</a> package to create multidimensional cartesian grids). By using FEM to solve TISE, and because this is a variational method, we ensure that the numerically calculated ground state energy is bounded from below by its theoretical value. Additionally, it allows for quickly solving the TISE using an input file that defines arbitrary potentials. Another very valuable feature is that it enables the calculation of how eigenenergies of a Hamiltonian change when varying any potential parameter.</p><h1 id="Capability-of-the-package"><a class="docs-heading-anchor" href="#Capability-of-the-package">Capability of the package</a><a id="Capability-of-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Capability-of-the-package" title="Permalink"></a></h1><p>This package is under construction and is focus to resolve the TISE over high performance protocol using functions from <a href="https://github.com/gridap/Gridap.jl">GRIDAP.jl</a> package. Main specific features of the package are: possibility of multi-thread parallelization; solver function for usual potential (e.g.: one and two dimensional quantum harmonic oscillator, one dimensional finite well potential and symmetric finite one dimensional Kronig-Penney potential); compute eigenvalue as a function of arbitrary potential parameter; solver function for two particles problems with different masses; and involve <a href="https://github.com/JuliaIO/JLD2.jl">JLD2</a> output format which allow us keep going the simulation or binary output which allow us write result data as value arrays to post-processing.</p><h1 id="Weak-formulation-and-eigenvalue-problem-(Galerkin-Method)"><a class="docs-heading-anchor" href="#Weak-formulation-and-eigenvalue-problem-(Galerkin-Method)">Weak formulation and eigenvalue problem (Galerkin Method)</a><a id="Weak-formulation-and-eigenvalue-problem-(Galerkin-Method)-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-formulation-and-eigenvalue-problem-(Galerkin-Method)" title="Permalink"></a></h1><p>Considering the TISE we have <span>$\hat{H}\ket{\psi } =\epsilon \ket{\psi }$</span> in coordinate representation we could write the equation by their Sturm-Liouville form as</p><p class="math-container">\[\underbrace{\hat{H}\ket{\psi } =\epsilon \ket{\psi }}_{\mathrm{TISE}} \Rightarrow \overbrace{-\nabla \cdotp ( p\nabla \psi ) +q\psi =\lambda r\psi }^{\mathrm{Sturm-Liouville}} \text{  if} \ \hat{H} =-\frac{\hbar^2}{2m}\nabla^2 +V( r) \Rightarrow \begin{cases} p( x) =\frac{\hbar ^{2}}{2m}(  &gt;0)\\ q( x) =V( r)\\ r( x) =1(  &gt;0) \end{cases}\]</p><p>For a variational problem first we approximate the wave function <span>$\psi \in \mathcal{H}$</span> by a function <span>$u\in U_{\mathrm{trial}}$</span> (where <span>$\mathcal{H}$</span> is a Hilbert space of infinite dimension in principle and where <span>$U_{\mathrm{trial}}$</span> is a approximate space of finite dimension for <span>$\mathcal{H}$</span>) and multiplying the PDE by a test function <span>$v\in V_{\mathrm{space}}\left( C^{1}\right)$</span> (notice that we don&#39;t need that <span>$v$</span> satisfy some boundary condition) and integrating over <span>$\Omega$</span> using the Green formula which says</p><p class="math-container">\[\int _{\Omega }( \partial _{j} h) gdx=-\int _{\Omega } h( \partial _{j} g) dx+\int _{\partial \Omega =\Gamma } hgn_{j} ds\]</p><p>where <span>$n_{j} =\vec{n} \cdotp e_{j}$</span> is the <span>$j$</span>-th of <span>$\vec{n}$</span> on the canonical base of <span>$\mathbb{R}^{d}$</span>. So</p><p class="math-container">\[-\nabla \cdotp ( p\nabla \psi ) +q\psi =\lambda r\psi \mathrm{\ }(\mathrm{in} \ \Omega ) \\ \mathrm{with} \ \begin{cases} \psi \Bigl|_{\partial \Omega =\Gamma } =0 &amp; (\mathrm{Dirichlet} \ \mathrm{BC})\\ {\frac{\partial \psi }{\partial n}}{\Bigl|}{_{\partial \Omega =\Gamma }}{=\nabla \psi \cdotp }{\vec{n}}{=c} &amp; (\mathrm{Neumann} \ \mathrm{BC}) \end{cases} \Rightarrow -\int _{\Omega }[ \nabla \cdotp ( p\nabla u)] vd\Omega +\int _{\Omega } quvd\Omega =\int _{\Omega } \lambda ruvd\Omega\]</p><blockquote><p>Note: In some cases this method is equivalent to Rayleigh-Ritz method, that is, the Galerkin method is more general but both came from functional minimization.</p></blockquote><p>if <span>$\begin{cases} g:=v &amp; \Rightarrow \partial g=\nabla v\\ \partial h:=\nabla \cdotp ( p\nabla u) &amp; \Rightarrow h=( p\nabla u) \end{cases}$</span> then</p><p class="math-container">\[\Rightarrow \int _{\Omega } p( \nabla u\cdotp \nabla v) d\Omega {-}{\int _{\Gamma }}{p}{(}{\nabla u\cdotp }{\vec{n}}{)}{vd\Gamma } +\int _{\Omega } quvd\Omega = \lambda \int _{\Omega } ruvd\Omega\]</p><p>and the problem to resolve would be like <span>$a( u,v) =\lambda b( u,v)$</span> where we had defined </p><p class="math-container">\[a( u,v) :=\int _{\Omega }[ p( \nabla u\cdotp \nabla v) +quv] d\Omega {-}{\int _{\Gamma }}{p}{(}{\nabla u\cdotp }{\vec{n}}{)}{vd\Gamma } \\ b( u,v) :=\int _{\Omega } ruvd\Omega\]</p><blockquote><p>Note: The integral over <span>$\Gamma$</span> boundary will avoid if we are considering Dirichlet&#39;s boundary conditions or has a fixed value is we are considering Neumann&#39;s boundary conditions.</p></blockquote><p>Now, we resolve the eigenvalue problem using the <strong>ARPACK</strong> package building affine operators (each affine operator has associated one matrix and one vector) like</p><p class="math-container">\[\begin{cases} a( u,v) =0\mathrm{\xrightarrow[affine\ operator]{associated}}\{A,\vec{\alpha }\}\\ b( u,v) =0\mathrm{\xrightarrow[affine\ operator]{associated}}\{B,\vec{\beta }\} \end{cases} \Rightarrow A\vec{\phi } =\lambda B\vec{\phi }\]</p><p>here <span>$u$</span> and <span>$v$</span> functions are such that <span>$u\in U_{\mathrm{trial}} ;v\in V_{\mathrm{space}}$</span> where <span>$U_{\mathrm{trial}}$</span> and <span>$V_{\mathrm{space}}$</span> are finite spaces which approximate the infinite Hilbert spaces where live <span>$\psi$</span> and <span>$\psi^{*}$</span>.</p><p>If we consider a base <span>$\mathcal{B} =\{\phi _{j}( x)\}_{j=1}^{N}$</span>, which expand all of the space <span>$U_{\mathrm{trial}}$</span>, we have <span>$u$</span> and <span>$v$</span> function which could be approximated (expanded in <span>$U,V$</span>) as</p><p class="math-container">\[\mathcal{B}_{U,V} =\{\phi _{j}( x)\}_{j=1}^{N} \Rightarrow f( x) =\sum\limits _{j=1}^{N} c_{j} \phi _{j}( x) \\ \Rightarrow \sum _{i,j=1}^{N} c_{i} c_{j}\left[\int\limits _{x_{i}}^{x_{f}} p( x)\frac{d\phi _{i}( x)}{dx}\frac{d\phi _{j}( x)}{dx} dx +\int\limits _{x_{i}}^{x_{f}} q( x) \phi _{i}( x) \phi _{j}( x) dx\right] = \dots \\ \dots = \lambda \sum _{i,j=1}^{N} c_{i} c_{j}\left[\int\limits _{x_{i}}^{x_{f}} r( x) \phi _{i}( x) \phi _{j}( x) dx\right] \Rightarrow \hat{A}\vec{\Phi } =\lambda (\hat{B}\vec{\Phi })\]</p><p>and defining following affine matrices</p><p class="math-container">\[A_{ij} := \int\nolimits _{x_{i}}^{x_{f}} p( x)\frac{d\phi _{i}( x)}{dx}\frac{d\phi _{j}( x)}{dx} dx+\int\nolimits _{x_{i}}^{x_{f}} q( x) \phi _{i}( x) \phi _{j}( x) dx \\ B_{ij} := \int\nolimits _{x_{i}}^{x_{f}} r( x) \phi _{i}( x) \phi _{j}( x) dx\]</p><p>and noting that we are solving at the end is a generalized eigenvalue problem with the form <span>$\hat{A}\vec{\Phi } =\lambda (\hat{B}\vec{\Phi })$</span>.</p><p>The computing problem implementation is resolved by <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl/tree/master">ARPACK</a> package (using LAPACK and BLAS libraries) which give us the possibility to compute only a subset of ordered pair (eigenvalue,eigenvector) like following (this method is called <strong>Shift-Invert mode</strong>):</p><p>If <span>$(\vec{\Phi } ,\lambda )$</span> is a eigenpair for <span>$(\hat{A} ,\hat{B})$</span> matrices and <span>$\sigma \neq \lambda$</span> then</p><p class="math-container">\[\underbrace{(\hat{A} -\sigma \hat{B})^{-1}\hat{B} \cdotp \vec{\Phi } =\vec{\nu } \cdotp \vec{\Phi }}_{\mathrm{Shift-Invert\ mode}} ;\ \nu _{j} =\frac{1}{( \lambda -\sigma )}\]</p><p>this allow us to transform the original eigenvalue problem to another one with different eigenvalues, where those <span>$\lambda \approx \sigma$</span> will have maximum <span>$\nu _{j}$</span> values.</p><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><ul><li>Sun, J. and Zhou, A., 2016. Finite element methods for eigenvalue problems. Chapman and Hall/CRC.</li><li>Lehoucq, R.B., Sorensen, D.C. and Yang, C., 1998. ARPACK users&#39; guide: solution of large-scale eigenvalue problems with implicitly restarted Arnoldi methods. Society for Industrial and Applied Mathematics.</li><li>Verdugo, F. and Badia, S., 2022. The software design of Gridap: a finite element package based on the Julia JIT compiler. Computer Physics Communications, 276, p.108341.</li></ul><h1 id="Implementation-of-FEMTISE-package"><a class="docs-heading-anchor" href="#Implementation-of-FEMTISE-package">Implementation of FEMTISE package</a><a id="Implementation-of-FEMTISE-package-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-FEMTISE-package" title="Permalink"></a></h1><p><a href="https://github.com/mendzmartin/FEMTISE.jl/blob/c4c72d603e9e8516f08a37f966d3ee3b91e7f719/src/functions/eigen_problem_definition_function.jl#L67-L79">Here</a> you can see the specific implementation of solve function to resolve eigen value problems.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../computing_details/">Computing details »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 17 November 2024 21:00">Sunday 17 November 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
